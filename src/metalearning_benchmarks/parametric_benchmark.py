from abc import abstractmethod

from tqdm import tqdm
import numpy as np

from typing import Optional
from metalearning_benchmarks.metalearning_benchmark import MetaLearningBenchmark
from metalearning_benchmarks.metalearning_task import MetaLearningTask


class ParametricBenchmark(MetaLearningBenchmark):
    """
    Serves as an ABC for creating a collection of tasks that are generated by a parametric function.
    For example, Quadratic1D draws n_task tuples (a_n,b_n,c_n) and creates a benchmark with elements
    benchmark[n] = y(x) = (a_n * (x + b_n)) ** 2 + c_n.

    By providing a parametrization and a prescription for sampling a given parameter set, a custom
    parametric benchmark can be created.

    For a more general base class, see base_benchmark.py.
    """

    def __init__(
        self, n_task, n_datapoints_per_task, output_noise, seed_task, seed_x, seed_noise
    ):
        super().__init__(
            n_task=n_task,
            n_datapoints_per_task=n_datapoints_per_task,
            output_noise=output_noise,
            seed_task=seed_task,
            seed_x=seed_x,
            seed_noise=seed_noise,
        )

        # define parameters and inputs
        self.params = (
            self.rng_task.rand(n_task, self.d_param)
            * (self.param_bounds[:, 1] - self.param_bounds[:, 0])
            + self.param_bounds[:, 0]
        )
        self.x = (
            self.rng_x.rand(n_task, n_datapoints_per_task, self.d_x)
            * (self.x_bounds[:, 1] - self.x_bounds[:, 0])
            + self.x_bounds[:, 0]
        )

        # compute the outputs
        self._pre_call_hook() # if sth has to be done before __call__
        self.y = np.zeros((self.x.shape[0], self.x.shape[1], self.d_y))
        for i in tqdm(range(self.n_task), desc="Generating tasks"):
            self.y[i] = self(param=self.params[i], x=self.x[i])

    @property
    @abstractmethod
    def d_param(self) -> int:
        """
        Has to be defined as a class property.
        The parameter dimension of the benchmark.
        """
        pass

    @property
    @abstractmethod
    def param_bounds(self) -> np.ndarray:
        """
        The bounds of the parameter values of the benchmark.
        return value shape: (d_param, 2)
        """
        pass

    @abstractmethod
    def __call__(self, x: np.ndarray, param: np.ndarray) -> np.ndarray:
        """
        Evaluate the function at given x and parameters. Do *not* add noise!

        Parameters
        ----------
        params : (d_params,)
        x : (..., d_x)

        Returns
        -------
        y : (..., d_y)
        """
        pass

    def _pre_call_hook(self):
        pass # can be overwritten if there is sth todo before __call__ is called

    def _get_task_by_index_without_noise(self, task_index: int):
        return MetaLearningTask(
            x=self.x[task_index], y=self.y[task_index], param=self.params[task_index]
        )


class ObjectiveFunctionBenchmark(ParametricBenchmark):
    def __init__(
        self, n_task, n_datapoints_per_task, output_noise, seed_task, seed_x, seed_noise
    ):
        assert self.d_y == 1
        super().__init__(
            n_task=n_task,
            n_datapoints_per_task=n_datapoints_per_task,
            output_noise=output_noise,
            seed_task=seed_task,
            seed_x=seed_x,
            seed_noise=seed_noise,
        )

    @property
    @abstractmethod
    def _x_min(self, param: np.ndarray) -> Optional[np.ndarray]:
        pass

    @property
    def has_x_min(self) -> bool:
        return self._x_min(self.params[0]) is not None

    def _call_task_by_param_without_noise(
        self, x: np.ndarray, param: np.ndarray
    ) -> np.ndarray:
        # check input
        n_points = x.shape[0]
        assert x.shape == (n_points, self.d_x)
        assert param.shape == (self.d_param,)

        # call task
        y = self(x=x, param=param)

        # check output
        assert y.shape == (n_points, self.d_y)
        return y

    def _call_task_by_param_with_noise(
        self, x: np.ndarray, param: np.ndarray
    ) -> np.ndarray:
        # check input
        n_points = x.shape[0]
        assert x.shape == (n_points, self.d_x)
        assert param.shape == (self.d_param,)

        # call task and add noise
        y = self._call_task_by_param_without_noise(x=x, param=param)
        y += self.output_noise * self.rng_noise.randn(*y.shape)

        # check output
        assert y.shape == (n_points, self.d_y)
        return y

    def call_task_by_index_with_noise(
        self, x: np.ndarray, task_index: int
    ) -> np.ndarray:
        param = self.params[task_index]
        return self._call_task_by_param_with_noise(x=x, param=param)

    def call_task_by_index_without_noise(
        self, x: np.ndarray, task_index: int
    ) -> np.ndarray:
        param = self.params[task_index]
        return self._call_task_by_param_without_noise(x=x, param=param)

    def call_all_tasks_without_noise(self, x: np.ndarray) -> np.ndarray:
        # check input
        n_points = x.shape[1]
        assert x.shape == (self.n_task, n_points, self.d_x)

        # call all tasks
        y = np.zeros((self.n_task, n_points, self.d_y))
        for i in range(self.n_task):
            y[i] = self.call_task_by_index_without_noise(x=x[i], task_index=i)

        return y

    def call_all_tasks_with_noise(self, x: np.ndarray) -> np.ndarray:
        # check input
        n_points = x.shape[1]
        assert x.shape == (self.n_task, n_points, self.d_x)

        # call all tasks
        y = np.zeros((self.n_task, n_points, self.d_y))
        for i in range(self.n_task):
            y[i] = self.call_task_by_index_with_noise(x=x[i], task_index=i)

        return y

    def x_min_by_index(self, task_index: int) -> Optional[np.ndarray]:
        if not self.has_x_min:
            return None

        param = self.params[task_index]
        x_min = np.atleast_1d(self._x_min(param))

        # check output
        assert x_min.shape == (self.d_x,)
        return x_min

    def y_min_by_index(self, task_index: int) -> Optional[np.ndarray]:
        if not self.has_x_min:
            return None

        x_min = self.x_min_by_index(task_index)
        y_min = self.call_task_by_index_without_noise(
            x=x_min[None], task_index=task_index
        )
        y_min = y_min.squeeze(0)

        # check output
        assert y_min.shape == (self.d_y,)
        return y_min

    def x_min_for_all_tasks(self) -> Optional[np.ndarray]:
        if not self.has_x_min:
            return None

        x_min = np.zeros((self.n_task, self.d_x))
        for i in range(self.n_task):
            x_min[i] = self.x_min_by_index(task_index=i)

        return x_min

    def y_min_for_all_tasks(self) -> Optional[np.ndarray]:
        if not self.has_x_min:
            return None

        y_min = np.zeros((self.n_task, self.d_y))
        for i in range(self.n_task):
            y_min[i] = self.y_min_by_index(task_index=i)

        return y_min
